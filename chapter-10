socket 编程难点


	1.poll函数使用；	// int poll(struct pollfd *fd, nfds_t nfds, int timeout)
	
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#inlcude <arpa/inet.h>
	#include <errno.h>
	
	#define __USE_XOPEN
	#include <poll.h>
	
	#define MAXLINE	80
	#define	SERV_PORT	8000
	#define OPEN_MAX	1024
	
	int main(int argc, char *argv[])
	{
		int i, j, maxi, listenfd, connfd, sockfd;
		int nready;
		ssize_t n;
		char buf[MAXLINE], str[INET_ADDRSTRLEN];
		socklen_t clilen;
		struct pollfd, client[OPEN_MAX];
		struct sockaddr_in cliaddr, seraddr;
		
		listenfd = socket(AF_INET, SOCK_STREAM, 0);
		
		bzero(&servaddr, sizeof(servaddr));
		servaddr.sin_family = AF_INET;
		servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
		servaddr.sin_port = htons(SERV_PORT);
		
		bind(listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr));
		
		listen(listenfd, 20);
		
		client[0].fd = listenfd;
		client[0].events = POLLRDNORM;
		
		for(i = 0; i < OPEN_MAX; i++)
			client[i] = -1;
		maxi = 0;
		
		for( ; ; ) {
			nready = poll(client, maxi+1, 0);
			if(client[0].revents & POLLRDNORM) {
				clilen = sizeof(cliaddr);
				connfd = accept(listenfd, (struct sockaddr *) &cliaddr, &clilen);
				
				printf("received form %s at PORT %d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, str, sizeof(str)),
				ntohs(cliaddr.sin_port));
				
				for(i = 1; i < OPEN_MAX; i++)
					if(client[i].fd < 0) {
						clien[i].fd = connfd;
						break;
					}
				if(i == OPEN_MAX)
					fprintf(stderr, "too many clients\n");
				client.events = POLLRDNORM;
				if (i > maxi)
					maxi = i;
				if (--nready <=0)
					continue;
			}
			
			for(i = 1; i <= maxi; i++) {
				if((sockfd = clientfd[i].fd) < 0)
					continue;
				if(client[i].reven & (POLLRDNORM | POLLERR)) {
					if((n = read(sockfd, buf, MAXLINE)) < 0) {
						if(errno == ECONNRSET) {
							printf("client[%d] aborted connection\n", i);
							close(sockfd);
							clent[i].fd = -1;
						} else {
							perror("read error");
							exit(1);	
						}
					} else if(n == 0) {
						printf("client[%d] closed connection\n", i);
						close(sockfd);
						clien[i].fd = -1;
					} else {
						for(j = 0; j < n; j++)
							buf[j] = toupper(buf[j]);
						writen(sockfd, buf, n);
					}
					if(--nready <= 0)
						break;
				}
			}
		}
	
		return 0;
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
